

server
develop(default) prod branches (drop master)
confit json based config (with json schema validation)
http or https or both? need to verify unit and e2e testing will run on https headless as well as headful
jasmine front and back if possible (no need to learn 2 testing frameworks
supertest e2e with db refresh between sections
nodemon for _me
separate starter scripts, no more starting server and ui in same terminal, they lose the server logs, makes it harder to debug
security module from mean.io?
custom logger to get graphql into logs
express modules to consider
import cookieParser from 'cookie-parser';
?import compress from 'compression';
import httpStatus from 'http-status';
import expressWinston from 'express-winston';
import expressValidation from 'express-validation';
import helmet from 'helmet';
import winstonInstance from './winston';
?import APIError from '../helpers/APIError';

multer or connect-busboy for file upload?
storing files in mongo, some blob type right?
simple server unit/e2e and ui unit/e2e test poc
pm2 vs nodemon, what do you need in that root pm2.js file?
db update strategy (versioned mongo scripts?, snapshots?)
json schema validation for everything
redoc docs for rest api
?? docs for graphql api
graphql first strategy.
business layer for graphql? Maybe if things get crazy. So it's all in the root functions (queryies/mutations object methods) and types (resolves for each property of type), if it gets crazy, the bust out a business.js file and put stuff in there, especially if you need to share between rest and gq right? POC: need to unit test graphql root and type methods. Is that doable??
shared schemas for validation in api and ui (separate from db driven rules/upload validation





node-base
separate config in config file and separate sections in there as well, so like nodeBase.middle
security goes here, cookie parsing, auth list, auth middleware and functions for graphql
errors/errorHandling, middleware, validation,



ui
need an error modal and associated interceptor. BUT... you'll get success even with error in graphql, so interceptor will have to look for errors property in graphql calls, so request will check for gq, then response will look for errors in response. LOOK AT ERROR CHOICES (see doc) and decide which way to go with the errors.
separate ui ngcli project that can easily be updated/started/built etc
store for pub/sub
no apollo cache for now, just make everything networkOnly
graphql subscribe? Say someone adds/updates a new rule and it gets approved (really added then), all clients could be notified? Be cool.
add material
add cisco comps AND... make sure their css is after the material one
scss default
fin- for comp prefix
flex-layout
responsive
local/dev/qa/prod config (probably not needed if on same domain?), still will have to build --prod (to aot and minimize) so will look for prod I figure unless you use other switches
ajax progress bar
initialization guard
auth routing guards
routing resolves?
auth directives for show/hide
unsubscription to observable in onDestroy






rules/upload validation
need db queries  as well as json schema (or at least regex) and all need to be in db, downloaded and used (and updated via admin), db stuff could simply be colName and db.coll.colName to look for existence on, and existence or non-existence, i..e might check if exists and check if already exists (can't have dups)




database
concurrency for puts, need to error if updateDate has changed
seed script for db and unitdb with csv templates
update versioning for updates
snapshots for qa and prod



